//
//  SwiftAudioKit
//
//  Created by Dionysios Karatzas.
//  Copyright Â© 2024 Dionysios Karatzas. All rights reserved.
//

import Foundation
import Combine

/// A `QualityAdjustmentEventProducer` generates `QualityAdjustmentEvent`s when there should be a change of quality
/// based on some information about interruptions.
class QualityAdjustmentEventProducer: EventProducer {
    /// `QualityAdjustmentEvent` is a list of events that can be generated by `QualityAdjustmentEventProducer`.
    ///
    /// - goDown: The quality should go down if possible.
    /// - goUp: The quality should go up if possible.
    enum QualityAdjustmentEvent: Event {
        case goDown
        case goUp
    }

    /// The listener that will be alerted when a new event occurs.
    weak var eventListener: EventListener?

    /// A boolean value indicating whether we're currently producing events or not.
    private(set) var isObserving = false

    /// Interruption counter. It will be used to determine whether the quality should change.
    var interruptionCount = 0 {
        didSet {
            checkInterruptionCount()
        }
    }

    /// Defines the delay within which the player waits for an interruption before upgrading the quality. Default value
    /// is 10 minutes.
    var adjustQualityTimeInterval: TimeInterval = 10 * 60 {
        didSet {
            restartTimer()
        }
    }

    /// Defines the maximum number of interruptions to have within the `adjustQualityTimeInterval` delay before
    /// downgrading the quality. Default value is 5.
    var adjustQualityAfterInterruptionCount = 5 {
        didSet {
            checkInterruptionCount()
        }
    }

    /// The timer used to adjust quality
    private var timerCancellable: AnyCancellable?

    /// Starts listening to the player events.
    func startProducingEvents() {
        guard !isObserving else { return }

        // Reset state
        resetState()

        // Mark as listening
        isObserving = true
    }

    /// Stops listening to the player events.
    func stopProducingEvents() {
        guard isObserving else { return }

        // Invalidate the timer
        timerCancellable?.cancel()
        timerCancellable = nil

        // Mark as not listening
        isObserving = false
    }

    /// Resets the state.
    private func resetState() {
        interruptionCount = 0
        restartTimer()
    }

    /// Restarts the timer with the current `adjustQualityTimeInterval`.
    private func restartTimer() {
        timerCancellable?.cancel()

        timerCancellable = Timer.publish(every: adjustQualityTimeInterval, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                self?.timerTicked()
            }
    }

    /// Checks that the interruption count is lower than `adjustQualityAfterInterruptionCount`. If it isn't, the
    /// function generates an event and resets its state.
    private func checkInterruptionCount() {
        guard isObserving else { return }

        if interruptionCount >= adjustQualityAfterInterruptionCount {
            // Invalidate the timer
            timerCancellable?.cancel()

            // Notify the listener
            eventListener?.onEvent(QualityAdjustmentEvent.goDown, generatedBy: self)

            // Reset state
            resetState()
        }
    }

    /// The quality adjuster ticked.
    private func timerTicked() {
        if interruptionCount == 0 {
            eventListener?.onEvent(QualityAdjustmentEvent.goUp, generatedBy: self)
        }

        // Reset state
        resetState()
    }

    deinit {
        stopProducingEvents()
    }
}

//
//  SwiftAudioKit
//
//  Created by Dionysios Karatzas.
//  Copyright Â© 2024 Dionysios Karatzas. All rights reserved.
//

import Combine
import AVFoundation

// MARK: - PlayerEventProducer

/// A `PlayerEventProducer` listens to notifications and observes events generated by an `AVPlayer`.
///
/// This class is responsible for monitoring the `AVPlayer` and generating events that correspond to
/// different playback states or changes. It communicates these events to an `EventListener` through the
/// `startProducingEvents` and `stopProducingEvents` methods.
class PlayerEventProducer: NSObject, EventProducer {
    /// The player to produce events with.
    ///
    /// Note that setting it has the same result as calling `stopProducingEvents`.
    var player: AVPlayer? {
        willSet {
            stopProducingEvents()
        }
    }

    /// The listener that will receive events.
    weak var eventListener: EventListener?

    /// Internal state to manage whether we're currently listening to events.
    private var isObserving = false

    /// Combine cancellables to manage subscriptions.
    private var cancellables = Set<AnyCancellable>()

    override init() {
        super.init()
    }

    /// Cleanup on deinit.
    deinit {
        stopProducingEvents()
    }

    /// Starts listening to the player events and producing corresponding events.
    func startProducingEvents() {
        guard let player, !isObserving else {
            return
        }
        isObserving = true

        observePlayerItemChanges(for: player)
        observePlayerTimeUpdates(for: player)
        observeNotifications()
    }

    /// Stops listening to player events and cleans up resources.
    func stopProducingEvents() {
        cancellables.removeAll()
        isObserving = false
    }

    /// Observes changes in the current `AVPlayerItem`.
    private func observePlayerItemChanges(for player: AVPlayer) {
        player.publisher(for: \.currentItem)
            .compactMap { $0 }
            .sink { [weak self] item in
                self?.registerItemObservers(for: item)
            }
            .store(in: &cancellables)

        player.publisher(for: \.status)
            .dropFirst()
            .sink { [weak self] status in
                guard let self else {
                    return
                }
                if status == .readyToPlay {
                    self.eventListener?.onEvent(PlayerEvent.readyToPlay, generatedBy: self)
                }
            }
            .store(in: &cancellables)
    }

    /// Observes periodic time updates in the player.
    private func observePlayerTimeUpdates(for player: AVPlayer) {
        Publishers.PlayheadProgressPublisher(interval: 1.0, player: player)
            .sink { [weak self] time in
                guard let self else {
                    return
                }
                self.eventListener?.onEvent(
                    PlayerEvent.progressed(time: CMTime(seconds: time, preferredTimescale: CMTimeScale(NSEC_PER_SEC))),
                    generatedBy: self
                )
            }
            .store(in: &cancellables)
    }

    /// Observes system notifications relevant to the player.
    private func observeNotifications() {
        #if os(iOS) || os(tvOS)
            observeAudioSessionNotifications()
        #endif

        NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime)
            .sink { [weak self] _ in
                self?.eventListener?.onEvent(PlayerEvent.endedPlaying(error: nil), generatedBy: self!)
            }
            .store(in: &cancellables)
    }

    #if os(iOS) || os(tvOS)
        /// Observes notifications related to `AVAudioSession`.
        private func observeAudioSessionNotifications() {
            let center = NotificationCenter.default

            center.publisher(for: AVAudioSession.interruptionNotification)
                .sink { [weak self] notification in
                    self?.handleAudioSessionInterruption(notification)
                }
                .store(in: &cancellables)

            center.publisher(for: AVAudioSession.routeChangeNotification)
                .sink { [weak self] note in
                    let reason = note.userInfo
                        .flatMap({ $0[AVAudioSessionRouteChangeReasonKey] as? UInt })
                        .map(AVAudioSession.RouteChangeReason.init) ?? .unknown
                    let deviceDisconnected = reason == .oldDeviceUnavailable

                    self?.eventListener?.onEvent(
                        PlayerEvent.routeChanged(deviceDisconnected: deviceDisconnected),
                        generatedBy: self!
                    )
                }
                .store(in: &cancellables)

            center.publisher(for: AVAudioSession.mediaServicesWereLostNotification)
                .sink { [weak self] _ in
                    self?.eventListener?.onEvent(PlayerEvent.sessionMessedUp, generatedBy: self!)
                }
                .store(in: &cancellables)

            center.publisher(for: AVAudioSession.mediaServicesWereResetNotification)
                .sink { [weak self] _ in
                    self?.eventListener?.onEvent(PlayerEvent.sessionMessedUp, generatedBy: self!)
                }
                .store(in: &cancellables)
        }

        /// Handles interruptions from `AVAudioSession`.
        private func handleAudioSessionInterruption(_ notification: Notification) {
            guard let userInfo = notification.userInfo,
                  let typeValue = userInfo[AVAudioSessionInterruptionTypeKey] as? UInt,
                  let interruptionType = AVAudioSession.InterruptionType(rawValue: typeValue) else {
                return
            }

            if interruptionType == .began {
                eventListener?.onEvent(PlayerEvent.interruptionBegan, generatedBy: self)
            } else if interruptionType == .ended {
                let shouldResume = (userInfo[AVAudioSessionInterruptionOptionKey] as? UInt)
                    .map { AVAudioSession.InterruptionOptions(rawValue: $0).contains(.shouldResume) } ?? false
                eventListener?.onEvent(PlayerEvent.interruptionEnded(shouldResume: shouldResume), generatedBy: self)
            }
        }
    #endif

    /// Registers observers for the given `AVPlayerItem`.
    private func registerItemObservers(for item: AVPlayerItem) {
        setupMetadataOutput(for: item)

        item.publisher(for: \.isPlaybackBufferEmpty)
            .dropFirst()
            .sink { [weak self] isBufferEmpty in
                guard let self, isBufferEmpty else {
                    return
                }
                self.eventListener?.onEvent(PlayerEvent.startedBuffering, generatedBy: self)
            }
            .store(in: &cancellables)

        item.publisher(for: \.isPlaybackLikelyToKeepUp)
            .dropFirst()
            .sink { [weak self] isLikelyToKeepUp in
                guard let self, isLikelyToKeepUp else {
                    return
                }
                self.eventListener?.onEvent(PlayerEvent.readyToPlay, generatedBy: self)
            }
            .store(in: &cancellables)

        item.publisher(for: \.duration)
            .compactMap { $0 }
            .sink { [weak self] duration in
                guard let self else {
                    return
                }
                self.eventListener?.onEvent(PlayerEvent.loadedDuration(duration: duration), generatedBy: self)
                self.eventListener?.onEvent(
                    PlayerEvent.loadedMetadata(metadata: item.asset.commonMetadata),
                    generatedBy: self
                )
            }
            .store(in: &cancellables)

        item.publisher(for: \.status)
            .dropFirst()
            .filter { $0 == .failed } // Ensure only failed statuses trigger the event listener
            .sink { [weak self] status in
                guard let self else {
                    return
                }
                self.eventListener?.onEvent(PlayerEvent.endedPlaying(error: item.error), generatedBy: self)
            }
            .store(in: &cancellables)

        item.publisher(for: \.loadedTimeRanges)
            .compactMap { $0.last?.timeRangeValue }
            .sink { [weak self] range in
                guard let self else {
                    return
                }
                self.eventListener?.onEvent(
                    PlayerEvent.loadedMoreRange(earliest: range.start, latest: CMTimeAdd(range.start, range.duration)),
                    generatedBy: self
                )
            }
            .store(in: &cancellables)
    }
}

extension PlayerEventProducer: AVPlayerItemMetadataOutputPushDelegate {
    /// Sets up the `AVPlayerItemMetadataOutput` to capture timed metadata from the `AVPlayerItem`.
    ///
    /// This method adds a metadata output to the given `AVPlayerItem` and sets the `PlayerEventProducer` as its delegate.
    /// The metadata output will capture timed metadata during playback and send updates via the `metadataOutput(_:didOutputTimedMetadataGroups:from:)` delegate method.
    ///
    /// - Parameter item: The `AVPlayerItem` to which the metadata output should be added.
    private func setupMetadataOutput(for item: AVPlayerItem) {
        let metadataOutput = AVPlayerItemMetadataOutput()
        metadataOutput.setDelegate(self, queue: DispatchQueue.main)
        item.add(metadataOutput)
    }

    /// Called when the metadata output captures timed metadata groups.
    ///
    /// This method is invoked by the `AVPlayerItemMetadataOutput` when it captures timed metadata during playback. The metadata is then flattened into an array of `AVMetadataItem` objects and passed to the `eventListener` as a `PlayerEvent.loadedMetadata` event.
    ///
    /// - Parameters:
    ///   - output: The `AVPlayerItemMetadataOutput` that captured the metadata.
    ///   - groups: An array of `AVTimedMetadataGroup` objects that contain the captured metadata.
    ///   - track: The `AVPlayerItemTrack` associated with the metadata. This parameter is optional and may be `nil`.
    func metadataOutput(
        _ output: AVPlayerItemMetadataOutput,
        didOutputTimedMetadataGroups groups: [AVTimedMetadataGroup],
        from track: AVPlayerItemTrack?
    ) {
        let metadataItems = groups.flatMap { $0.items }
        eventListener?.onEvent(PlayerEvent.loadedMetadata(metadata: metadataItems), generatedBy: self)
    }
}

// MARK: - PlayerEvent

extension PlayerEventProducer {
    /// The events that can be generated by `PlayerEventProducer`.
    ///
    /// These events represent different states or changes related to the `AVPlayer`. They are used to notify
    /// the `EventListener` of important playback events.
    enum PlayerEvent: Event {
        /// The player has started buffering.
        case startedBuffering

        /// The player is ready to play.
        case readyToPlay

        /// The player has loaded more range of the content, from the earliest to the latest specified time.
        ///
        /// - Parameters:
        ///   - earliest: The earliest time of the newly loaded range.
        ///   - latest: The latest time of the newly loaded range.
        case loadedMoreRange(earliest: CMTime, latest: CMTime)

        /// The player has loaded metadata.
        ///
        /// - Parameter metadata: An array of `AVMetadataItem` objects representing the metadata.
        case loadedMetadata(metadata: [AVMetadataItem])

        /// The player has loaded the duration of the content.
        ///
        /// - Parameter duration: The total duration of the content.
        case loadedDuration(duration: CMTime)

        /// The player's playback has progressed to a new time.
        ///
        /// - Parameter time: The current time of the playback progress.
        case progressed(time: CMTime)

        /// The player has finished playing, either successfully or due to an error.
        ///
        /// - Parameter error: An optional error that indicates why playback ended. If `nil`, playback ended successfully.
        case endedPlaying(error: Error?)

        /// The player's playback was interrupted.
        case interruptionBegan

        /// The player's playback interruption ended.
        ///
        /// - Parameter shouldResume: A Boolean value indicating whether playback should resume after the interruption.
        case interruptionEnded(shouldResume: Bool)

        /// The audio route has changed.
        case routeChanged(deviceDisconnected: Bool)

        /// The audio session encountered an unexpected issue.
        case sessionMessedUp
    }
}
